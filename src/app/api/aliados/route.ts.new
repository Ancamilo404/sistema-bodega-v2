import { prisma } from "@/lib/prisma";
import { response } from "@/lib/response";
import { getAuthUser } from "@/lib/getAuthUser";
import { logHistorial } from "@/lib/logHistorial";
import { validateBody } from "@/lib/validateBody";
import { aliadoSchema } from "@/schemas/aliado";
import DOMPurify from "isomorphic-dompurify";

// GET /api/aliados?search=...&estado=...&documento=...&fechaInicio=...&fechaFin=...&limit=50&offset=0
export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);

    const search = searchParams.get("search") || "";
    const estado = searchParams.get("estado")?.toUpperCase();
    const documento = searchParams.get("documento") || "";
    const fechaInicio = searchParams.get("fechaInicio");
    const fechaFin = searchParams.get("fechaFin");
    const limit = Math.min(parseInt(searchParams.get("limit") || "50"), 100);
    const offset = Math.max(0, parseInt(searchParams.get("offset") || "0"));

    // ✅ Usar findMany en lugar de raw queries
    const where: any = {
      deletedAt: null,
      OR: [
        { nombre: { contains: search, mode: 'insensitive' } },
        { documento: { contains: search, mode: 'insensitive' } },
        { telefono: { contains: search, mode: 'insensitive' } },
        { correo: { contains: search, mode: 'insensitive' } },
        { direccion: { contains: search, mode: 'insensitive' } },
      ],
    };

    if (estado && ['ACTIVO', 'BLOQUEADO'].includes(estado)) {
      where.estado = estado;
    }

    if (documento) {
      where.documento = documento;
    }

    if (fechaInicio && fechaFin) {
      where.fechaRegistro = {
        gte: new Date(fechaInicio),
        lte: new Date(fechaFin),
      };
    }

    // ✅ Obtener total y lista con paginación
    const [aliados, total] = await Promise.all([
      prisma.aliado.findMany({
        where,
        include: {
          _count: {
            select: { productos: { where: { deletedAt: null } } },
          },
        },
        skip: offset,
        take: limit,
        orderBy: { fechaRegistro: 'desc' },
      }),
      prisma.aliado.count({ where }),
    ]);

    // ✅ Serializar fechas y agregar conteo
    const aliadosSerializados = aliados.map((a: any) => ({
      ...a,
      fechaRegistro: a.fechaRegistro?.toISOString() || null,
      productos: a._count?.productos || 0,
    })).map(({ _count, ...rest }: any) => rest);

    return response({
      data: { items: aliadosSerializados, total, limit, offset },
      message: "Aliados listados correctamente",
    });
  } catch (e: unknown) {
    const error = e as any;
    console.error("Error en /api/aliados:", {
      message: error.message,
      code: error.code,
      timestamp: new Date().toISOString(),
    });
    return response({ error: error.message || "Error al listar aliados" }, 500);
  }
}

// POST /api/aliados → crea o reactiva aliado
export async function POST(req: Request) {
  try {
    const user = await getAuthUser(req);
    if (!user || !["ADMIN", "TRABAJADOR"].includes(user.rol)) {
      return response({ error: "No autorizado" }, 403);
    }

    const body = await validateBody(req, aliadoSchema);
    if (body.documento)
      body.documento = DOMPurify.sanitize(body.documento.trim());
    if (body.telefono) body.telefono = body.telefono.trim();
    if (body.correo) body.correo = DOMPurify.sanitize(body.correo.trim());
    if (body.direccion) body.direccion = DOMPurify.sanitize(body.direccion.trim());

    const existing = await prisma.aliado.findUnique({
      where: { documento: body.documento },
    });

    let result;
    if (existing && existing.deletedAt) {
      result = await prisma.aliado.update({
        where: { id: existing.id },
        data: { ...body, deletedAt: null, estado: "ACTIVO" },
      });

      await logHistorial({
        tipo: "ACTUALIZAR",
        accion: `Aliado ${result.nombre} reactivado`,
        entidad: "Aliado",
        entidadId: result.id,
        usuarioId: user.id,
        detalle: result,
        ip: req.headers.get("x-forwarded-for") || undefined,
      });

      return response(
        {
          data: {
            ...result,
            fechaRegistro: result.fechaRegistro.toISOString(),
          },
          message: "Aliado reactivado correctamente",
        },
        200
      );
    }

    if (existing) {
      return response({ error: "Documento ya registrado" }, 409);
    }

    result = await prisma.aliado.create({
      data: body,
    });

    await logHistorial({
      tipo: "CREAR",
      accion: `Aliado ${result.nombre} creado`,
      entidad: "Aliado",
      entidadId: result.id,
      usuarioId: user.id,
      detalle: result,
      ip: req.headers.get("x-forwarded-for") || undefined,
    });

    return response(
      {
        data: {
          ...result,
          fechaRegistro: result.fechaRegistro.toISOString(),
        },
        message: "Aliado creado correctamente",
      },
      201
    );
  } catch (e: unknown) {
    const error = e as any;
    if (error.code === "P2002")
      return response({ error: "Documento o correo ya registrado" }, 409);
    if (error.code === "VALIDATION")
      return response({ error: error.error }, 400);
    return response({ error: error.message || "Error al crear aliado" }, 500);
  }
}
